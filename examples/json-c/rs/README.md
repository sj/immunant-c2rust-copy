This directory contains the Rust translation of the libjson-c C code in the
directory above.

# Running `idiomize`

The root of the crate is `lib.rs`.  You must also pass `--crate-type rlib` as
part of the `rustc` arguments, else you will get an error about missing `main`.

# Ownership analysis

The `idiomize` ownership analysis works on this code, but requires a few
annotations as input:

    ./run-idiomize.sh \
        select box '
            crate;
            desc(
                (foreign_item && fn && (name("free") || name("realloc"))) ||
                (field && path(::arraylist::array_list::free_fn)) ||
                (field && path(::json_object::json_object::_delete))
            );
            desc(match_ty(*mut __t));
        ' \; \
        test_analysis_ownership     # or other idiomize commands

# Cleanup plans

The overall plan for cleaning up unsafety has two parts.

## Function signatures

The first step is to remove all unsafe types from function signatures.

 * Add extern wrappers around all public APIs.  That is, for every function
   `foo`, create a `foo_wrapper` that calls `foo` and is exported as symbol
   `foo`.  Calls within the library still call `foo` directly.  Having a layer
   of indirection between the C API an the actual implementation lets us change
   the type signature of the "real" `foo` arbitrarily, without affecting the
   public (C) API of the library.

   This has already been done, using the `wrap_api` command.

 * Eliminate uses of `*mut c_void` by making types in the `arraylist` and
   `linkhash` modules generic.  The easy option is to replace `*mut c_void`
   with generic `*mut T`.  The harder but more idiomatic option is to replace
   it with `T`.  (This may require manual changes, such as making `array_list`
   allocate `n * sizeof(T)` instead of `n * sizeof(void*)` bytes.)

   This can be done using `mark_related_types` to collect all the relevant
   instances of `*mut c_void`, followed by `generalize_items` to make the
   structs and functions generic.  This has been tested, but not yet applied.

 * Eliminate uses of `*const c_char` by replacing them with `&CStr`.

   This should be possible with `retype_argument`.

 * Eliminate remaining uses of raw pointers using the ownership analysis.

   This requires `ownership_split_variants` and a new command to convert raw
   pointers to `&` or `&mut` references while introducing appropriate lifetime
   bounds.  Alternatively, it may be possible to use `ownership_mark_pointers`
   and `bitcast_retype` to convert them to `&`/`&mut` with invalid lifetimes,
   and fix up the lifetimes later with a separate pass.

   Recommended approach is to work module by module, fixing up `arraylist`,
   `linkhash`, `printbuf`, and `json_object` one at a time.  Leave annotations
   generated by `ownership_split_variants` in place until the end so that calls
   between modules will be fixed up automatically.

At the end of this step, the internal APIs will be safe, but with casts to and
from the unsafe forms around every function call.  For example, pointers inside
of structures will be `Box<T>`, but will be allocated by transmuting the result
of `malloc` and freed by transmuting back to a raw pointer and calling `free`.


## Function bodies

The second step is to remove unsafe behavior within individual function bodies.

 * Fix `arraylist` and `linkhash` manually, by replacing them with thin
   wrappers around `Vec` and `HashMap`.  Note that the `linkhash` replacement
   may be a little tricky because `lh_table` provides direct access to entries
   and iterators.

   The `printbuf` module may also need some manual fixes.

 * Replace variadic function calls with macros.  These are used only for
   formatting, as is common in C.  There is existing support for this fix in
   the form of the `convert_format_string` and `func_to_macro` transforms.

 * Replace direct memory allocation with `Box::new` and `drop`.  Most json-c
   code uses `calloc` where one of the arguments is `sizeof(T)`, so this
   conversion should be relatively straightforward.

 * The code will likely contain a large number of redundant conversions.  For
   example, transmuting an argument from `Box` to `*mut`, then transmuting back
   to `Box` to pass it to another function.  These conversions are unsafe and
   are not actually needed, as they return the argument to its original form.
   It should be possible to write a transform that recognizes and eliminates
   these no-op conversion chains.
